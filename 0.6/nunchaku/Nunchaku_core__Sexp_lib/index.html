<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Nunchaku_core__Sexp_lib (nunchaku.Nunchaku_core__Sexp_lib)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">nunchaku</a> &#x00BB; Nunchaku_core__Sexp_lib</nav><h1>Module <code>Nunchaku_core__Sexp_lib</code></h1><h2 id="simple-and-efficient-s-expression-parsing/printing"><a href="#simple-and-efficient-s-expression-parsing/printing" class="anchor"></a>Simple and efficient S-expression parsing/printing</h2><p>Windows-aware printer and parser, using ocamllex/ocamlyacc</p></header><dl><dt class="spec type" id="type-or_error"><a href="#type-or_error" class="anchor"></a><code><span class="keyword">type </span>'a or_error</code><span class="keyword"> = </span><code>[ </code><table class="variant"><tr id="type-or_error.Ok" class="anchored"><td class="def constructor"><a href="#type-or_error.Ok" class="anchor"></a><code><span class="keyword">| </span></code><code>`Ok<span class="keyword"> of </span><span class="type-var">'a</span></code></td></tr><tr id="type-or_error.Error" class="anchored"><td class="def constructor"><a href="#type-or_error.Error" class="anchor"></a><code><span class="keyword">| </span></code><code>`Error<span class="keyword"> of </span>string</code></td></tr></table><code> ]</code></dt><dt class="spec type" id="type-sequence"><a href="#type-sequence" class="anchor"></a><code><span class="keyword">type </span>'a sequence</code><code><span class="keyword"> = </span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> unit</code></dt><dt class="spec type" id="type-gen"><a href="#type-gen" class="anchor"></a><code><span class="keyword">type </span>'a gen</code><code><span class="keyword"> = </span>unit <span>&#45;&gt;</span> <span class="type-var">'a</span> option</code></dt><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type </span>t</code><span class="keyword"> = </span><code>[ </code><table class="variant"><tr id="type-t.Atom" class="anchored"><td class="def constructor"><a href="#type-t.Atom" class="anchor"></a><code><span class="keyword">| </span></code><code>`Atom<span class="keyword"> of </span>string</code></td></tr><tr id="type-t.List" class="anchored"><td class="def constructor"><a href="#type-t.List" class="anchor"></a><code><span class="keyword">| </span></code><code>`List<span class="keyword"> of </span><a href="index.html#type-t">t</a> list</code></td></tr></table><code> ]</code></dt><dt class="spec type" id="type-sexp"><a href="#type-sexp" class="anchor"></a><code><span class="keyword">type </span>sexp</code><code><span class="keyword"> = </span><a href="index.html#type-t">t</a></code></dt></dl><dl><dt class="spec value" id="val-atom"><a href="#val-atom" class="anchor"></a><code><span class="keyword">val </span>atom : string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-list"><a href="#val-list" class="anchor"></a><code><span class="keyword">val </span>list : <a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-pp"><a href="#val-pp" class="anchor"></a><code><span class="keyword">val </span>pp : <a href="index.html#type-t">t</a> CCFormat.printer</code></dt><dd><p>Pretty-printer nice on human eyes (including indentation)</p></dd></dl><dl><dt class="spec value" id="val-to_string"><a href="#val-to_string" class="anchor"></a><code><span class="keyword">val </span>to_string : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string</code></dt><dt class="spec value" id="val-to_chan"><a href="#val-to_chan" class="anchor"></a><code><span class="keyword">val </span>to_chan : Stdlib.out_channel <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-to_file"><a href="#val-to_file" class="anchor"></a><code><span class="keyword">val </span>to_file : string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt></dl><dl><dt class="spec type" id="type-parse_result"><a href="#type-parse_result" class="anchor"></a><code><span class="keyword">type </span>'a parse_result</code><span class="keyword"> = </span><code>[ </code><table class="variant"><tr id="type-parse_result.or_error" class="anchored"><td class="def type"><a href="#type-parse_result.or_error" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="type-var">'a</span> <a href="index.html#type-or_error">or_error</a></code></td></tr><tr id="type-parse_result.End" class="anchored"><td class="def constructor"><a href="#type-parse_result.End" class="anchor"></a><code><span class="keyword">| </span></code><code>`End</code></td></tr></table><code> ]</code></dt><dd><p>A parser of <code>'a</code> can return <code>`Ok x</code> when it parsed a value, or <code>`Error e</code> when a parse error was encountered, or <code>`End</code> if the input was empty</p></dd></dl><div class="spec module" id="module-Decoder"><a href="#module-Decoder" class="anchor"></a><code><span class="keyword">module </span><a href="Decoder/index.html">Decoder</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec value" id="val-parse_string"><a href="#val-parse_string" class="anchor"></a><code><span class="keyword">val </span>parse_string : string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <a href="index.html#type-or_error">or_error</a></code></dt><dd><p>Parse a string</p></dd></dl><dl><dt class="spec value" id="val-parse_chan"><a href="#val-parse_chan" class="anchor"></a><code><span class="keyword">val </span>parse_chan : Stdlib.in_channel <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <a href="index.html#type-or_error">or_error</a></code></dt><dd><p>Parse a S-expression from the given channel. Can read more data than necessary, so don't use this if you need finer-grained control (e.g. to read something else <b>after</b> the S-exp)</p></dd></dl><dl><dt class="spec value" id="val-parse_chan_list"><a href="#val-parse_chan_list" class="anchor"></a><code><span class="keyword">val </span>parse_chan_list : Stdlib.in_channel <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> list <a href="index.html#type-or_error">or_error</a></code></dt><dt class="spec value" id="val-parse_file"><a href="#val-parse_file" class="anchor"></a><code><span class="keyword">val </span>parse_file : string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <a href="index.html#type-or_error">or_error</a></code></dt><dd><p>Open the file and read a S-exp from it</p></dd></dl><dl><dt class="spec value" id="val-parse_file_list"><a href="#val-parse_file_list" class="anchor"></a><code><span class="keyword">val </span>parse_file_list : string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> list <a href="index.html#type-or_error">or_error</a></code></dt><dd><p>Open the file and read a S-exp from it</p></dd></dl></div></body></html>